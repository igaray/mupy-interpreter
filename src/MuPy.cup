package MuPy;

import java.io.*;
import java.lang.Exception;
import java.lang.String;
import java_cup.runtime.*;
import MuPy.SymbolTable;
import MuPy.OurSymbol;

action code
{:
    private static boolean debug = false;

    private SymbolTable st = new SymbolTable();
:}

parser code
{:

    public static void main(String args[])
    {
        try {
            new parser(new Yylex(System.in)).parse();
        } catch (Exception e)   {
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    public void syntax_error(java_cup.runtime.Symbol sym) {
        System.out.println("Error parsing at line " + (sym.left + 1));
        System.exit(1);
    }
:}

terminal PRINT;
terminal PERIOD;
terminal ENTER;
terminal STR;
terminal BRACE_OPEN;
terminal BRACE_CLOSE;
terminal PAREN_OPEN;
terminal PAREN_CLOSE;
terminal COLON;
terminal ADD;
terminal SUB;
terminal MUL;
terminal DIV;
terminal ASS;
terminal ASS_ADD;
terminal ASS_MUL;
terminal String  STRING;
terminal String  IDENTIFIER;
terminal Integer INTEGER;

non terminal program;
non terminal statement_list;
non terminal statement;
non terminal print;
non terminal assignment;
non terminal String expression;
non terminal String postfix_expression;
non terminal String slice;
non terminal String slice_expression;

precedence left ADD, SUB;
precedence left MUL, DIV;

start with program;

program
    ::= statement_list:stmntlst 
        PERIOD 
        {:
            st.print();            
        :}
        ENTER
    ;

statement_list
    ::= statement:stmnt 
        ENTER 
        statement_list:stmntlst
    |   
    ;

statement
    ::= print:p
        {: 
            if (debug) System.out.println("S:01"); 
        :}
    |   assignment:asgnmt
        {: 
            if (debug) System.out.println("S:02"); 
        :}
    ;

print   
    ::= PRINT expression:expr
        {: 
            if (debug) System.out.println("S:03");
            OurSymbol exprsym = st.get(expr);
            System.out.println(exprsym.getValue().toString());
        :}
    ;

assignment
    ::= IDENTIFIER:id ASS expression:expr
        {: 
            if (debug) System.out.println("S:04");
            OurSymbol sym = st.get(expr);
            Value     val = sym.getValue();

            if (st.isDeclared(id)) {
                st.setValue(id, val);
            }
            else {
                int res = st.addVar(id, val);
            }
        :}
    |   IDENTIFIER:id ASS_ADD expression:expr
        {: 
            if (debug) System.out.println("S:05"); 
        :}
    |   IDENTIFIER:id ASS_MUL expression:expr
        {: 
            if (debug) System.out.println("S:06"); 
        :}
        ;

expression
    ::= expression:expr1 ADD expression:expr2
        {: 
            if (debug) System.out.println("S:07"); 
        :}
    |   expression:expr1 SUB expression:expr2
        {: 
            if (debug) System.out.println("S:08"); 
        :}
    |   expression:expr1 MUL expression:expr2
        {: 
            if (debug) System.out.println("S:09"); 
        :}
    |   expression:expr1 DIV expression:expr2
        {: 
            if (debug) System.out.println("S:10"); 
        :}
    |   ADD expression:expr
        {: 
            /* This doesn't really do anything.
             * If the value of the expression is an integer, then
             * a unary plus will not change its sign or value.
             * If the value is a string, there is nothing to concatenate
             * with, although strictly it should emit an error. 
             */
            if (debug) System.out.println("S:11");
            RESULT = expr;
        :}
    |   SUB expression:expr
        {: 
            if (debug) System.out.println("S:12");
            OurSymbol sym = st.get(expr);
            if (! sym.getValue().isInt())
                throw new Exception("Type error: trying to change sign of a non-integer value.");
            RESULT = st.addAnonVar(new Value( - (Integer)sym.getValue().getValue()) );
        :}
    |   PAREN_OPEN expression:expr PAREN_CLOSE
        {: 
            if (debug) System.out.println("S:13");
            RESULT = expr; 
        :}
    |   postfix_expression:pfexpr
        {: 
            if (debug) System.out.println("S:14");
            RESULT = pfexpr;
        :}
    ;

postfix_expression
    ::= IDENTIFIER:id
        slice:slc
        {: 
            if (debug) System.out.println("S:15");
            if (slc == null) {
                if (! st.isDeclared(id))
                    throw new Exception("Unknown variable: " + id);
                RESULT = id;
            }
            else {
                RESULT = id;
            }
        :}
    |   INTEGER:intgr
        {: 
            if (debug) System.out.println("S:16");
            RESULT = st.addAnonVar(new Value(intgr));
        :}
    |   STRING:strng
        {: 
            if (debug) System.out.println("S:17"); 
            RESULT = st.addAnonVar(new Value(strng));
        :}
    |   STR
        expression:expr
        {: 
            /* First, we check whether the result of evaluating the 
             * expression expr is in the symbol table.
             * It always should be, otherwise a parse error ocurred.
             * Next, we get the corresponding symbol, extract its value, 
             * convert it into a string, and put the result in an 
             * anonymous variable in the symbol table.
             */
            if (debug) System.out.println("S:18");
            if (! st.isDeclared(expr))
                throw new Exception("Unknown: " + expr);
            OurSymbol sym = st.get(expr);
            Value     val = sym.getValue();
            String    str = val.toString();
            RESULT = st.addAnonVar(new Value(str));
        :}
    ;

slice
    ::= BRACE_OPEN expression:expr slice_expression:sexpr BRACE_CLOSE
        {: 
            if (debug) System.out.println("S:19");
            if (sexpr == null) {
                RETURN = expr;
            }
            else {
                OurSymbol sym1 = st.get(expr);
                OurSymbol sym2 = st.get(slice_expression);
                Value     val1 = sym1.getValue();
                Value     val2 = sym2.getValue();
                if (! val1.isInt()) {
                    throw Exception("");
                }
                if (! val2.isInt()) {
                    throw Exception("");
                }
                RETURN = RangeValue(0, 0);
            }
        :}
    |
    ;

slice_expression
    ::= COLON expression:expr
        {:
            if (debug) System.out.println("S:20"); 
            RETURN = expr;
        :}
    |
    ;
